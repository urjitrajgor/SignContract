{"ast":null,"code":"'use strict';\n/**\n * Make certain getters enumnerable\n *\n * This can be used to add additional getters that are enumerable and hence\n * show up on an `Object.keys()` call.\n *\n * @param {Object} object - The object it should be applied to\n * @param {Array.<String>} fields - The fields that should be made enumnerable\n */\n\nconst addEnumerableGetters = (object, fields) => {\n  for (const field of fields) {\n    let prop;\n    let proto = object; // Walk up the proottype chain until a property with the given name is\n    // found\n\n    while (prop === undefined) {\n      proto = Object.getPrototypeOf(proto);\n\n      if (proto === null) {\n        throw new Error(\"no getter named '\".concat(field, \"' found\"));\n      }\n\n      prop = Object.getOwnPropertyDescriptor(proto, field);\n    } // There is a property with the correct name, but it's not a getter\n\n\n    if (prop.get === undefined) {\n      throw new Error(\"no getter named '\".concat(field, \"' found\"));\n    }\n\n    Object.defineProperty(object, field, {\n      enumerable: true,\n      get: prop.get\n    });\n  }\n};\n/**\n * Makes all properties with a leading underscore non-enumerable.\n *\n * @param {Object} object - The object it should be applied to\n */\n\n\nconst hidePrivateFields = object => {\n  for (const key in object) {\n    if (key[0] === '_') {\n      Object.defineProperty(object, key, {\n        enumerable: false\n      });\n    }\n  }\n};\n\nmodule.exports = {\n  addEnumerableGetters,\n  hidePrivateFields\n};","map":null,"metadata":{},"sourceType":"script"}