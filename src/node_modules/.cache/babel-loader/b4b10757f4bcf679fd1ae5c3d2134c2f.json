{"ast":null,"code":"'use strict';\n\nconst dagPB = require('ipld-dag-pb');\n\nconst dagCBOR = require('ipld-dag-cbor');\n\nconst raw = require('ipld-raw');\n\nconst promisify = require('promisify-es6');\n\nconst CID = require('cids');\n\nconst waterfall = require('async/waterfall');\n\nconst block = require('../block');\n\nconst resolvers = {\n  'dag-cbor': dagCBOR.resolver,\n  'dag-pb': dagPB.resolver,\n  raw: raw.resolver\n};\n\nmodule.exports = send => {\n  return promisify((cid, path, options, callback) => {\n    if (typeof path === 'function') {\n      callback = path;\n      path = undefined;\n    }\n\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n\n    options = options || {};\n    path = path || '';\n\n    if (CID.isCID(cid)) {\n      cid = cid.toBaseEncodedString();\n    }\n\n    waterfall([cb => {\n      send({\n        path: 'dag/resolve',\n        args: cid + '/' + path,\n        qs: options\n      }, cb);\n    }, (resolved, cb) => {\n      block(send).get(new CID(resolved['Cid']['/']), (err, ipfsBlock) => {\n        cb(err, ipfsBlock, resolved['RemPath']);\n      });\n    }, (ipfsBlock, path, cb) => {\n      const dagResolver = resolvers[ipfsBlock.cid.codec];\n\n      if (!dagResolver) {\n        const error = new Error(\"Missing IPLD format \\\"\".concat(ipfsBlock.cid.codec, \"\\\"\"));\n        error.missingMulticodec = ipfsBlock.cid.codec;\n        return cb(error);\n      }\n\n      let res;\n\n      try {\n        res = dagResolver.resolve(ipfsBlock.data, path);\n      } catch (err) {\n        return cb(err);\n      }\n\n      cb(null, res);\n    }], callback);\n  });\n};","map":null,"metadata":{},"sourceType":"script"}