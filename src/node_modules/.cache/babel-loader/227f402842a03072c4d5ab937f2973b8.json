{"ast":null,"code":"'use strict';\n\nconst CID = require('cids');\n\nconst protons = require('protons');\n\nconst proto = protons(require('./dag.proto.js'));\n\nconst DAGLink = require('./dag-link');\n\nconst DAGNode = require('./dag-node');\n\nexports = module.exports;\n\nfunction cid(node, callback) {\n  if (node.multihash) {\n    return callback(null, new CID(node.multihash));\n  }\n\n  callback(new Error('not valid dagPB node'));\n}\n\nfunction serialize(node, callback) {\n  let serialized; // If the node is not an instance of a DAGNode, the link.hash might be a Base58 encoded string; decode it\n\n  if (node.constructor.name !== 'DAGNode' && node.links) {\n    node.links = node.links.map(link => {\n      return DAGLink.util.isDagLink(link) ? link : DAGLink.util.createDagLinkFromB58EncodedHash(link);\n    });\n  }\n\n  try {\n    serialized = proto.PBNode.encode(toProtoBuf(node));\n  } catch (err) {\n    return callback(err);\n  }\n\n  callback(null, serialized);\n}\n\nfunction deserialize(data, callback) {\n  const pbn = proto.PBNode.decode(data);\n  const links = pbn.Links.map(link => {\n    return new DAGLink(link.Name, link.Tsize, link.Hash);\n  });\n  const buf = pbn.Data == null ? Buffer.alloc(0) : Buffer.from(pbn.Data);\n  DAGNode.create(buf, links, callback);\n}\n\nfunction toProtoBuf(node) {\n  const pbn = {};\n\n  if (node.data && node.data.length > 0) {\n    pbn.Data = node.data;\n  } else {\n    // NOTE: this has to be null in order to match go-ipfs serialization `null !== new Buffer(0)`\n    pbn.Data = null;\n  }\n\n  if (node.links && node.links.length > 0) {\n    pbn.Links = node.links.map(link => {\n      return {\n        Hash: link.multihash,\n        Name: link.name,\n        Tsize: link.size\n      };\n    });\n  } else {\n    pbn.Links = null;\n  }\n\n  return pbn;\n}\n\nexports.serialize = serialize;\nexports.deserialize = deserialize;\nexports.cid = cid;","map":null,"metadata":{},"sourceType":"script"}