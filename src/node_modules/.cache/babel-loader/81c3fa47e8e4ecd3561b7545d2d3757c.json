{"ast":null,"code":"'use strict';\n\nconst multiaddr = require('multiaddr');\n/*\n * Valid combinations\n */\n\n\nconst DNS4 = base('dns4');\nconst DNS6 = base('dns6');\n\nconst _DNS = or(base('dnsaddr'), DNS4, DNS6);\n\nconst IP = or(base('ip4'), base('ip6'));\nconst TCP = or(and(IP, base('tcp')), and(_DNS, base('tcp')));\nconst UDP = and(IP, base('udp'));\nconst UTP = and(UDP, base('utp'));\nconst DNS = or(and(_DNS, base('tcp')), _DNS);\nconst WebSockets = or(and(TCP, base('ws')), and(DNS, base('ws')));\nconst WebSocketsSecure = or(and(TCP, base('wss')), and(DNS, base('wss')));\nconst HTTP = or(and(TCP, base('http')), and(IP, base('http')), and(DNS, base('http')), and(DNS));\nconst HTTPS = or(and(TCP, base('https')), and(IP, base('https')), and(DNS, base('https')));\nconst WebRTCStar = or(and(WebSockets, base('p2p-webrtc-star'), base('ipfs')), and(WebSocketsSecure, base('p2p-webrtc-star'), base('ipfs')));\nconst WebSocketStar = or(and(WebSockets, base('p2p-websocket-star'), base('ipfs')), and(WebSocketsSecure, base('p2p-websocket-star'), base('ipfs')), and(WebSockets, base('p2p-websocket-star')), and(WebSocketsSecure, base('p2p-websocket-star')));\nconst WebRTCDirect = or(and(HTTP, base('p2p-webrtc-direct')), and(HTTPS, base('p2p-webrtc-direct')));\nconst Reliable = or(WebSockets, WebSocketsSecure, HTTP, HTTPS, WebRTCStar, WebRTCDirect, TCP, UTP); // Unlike ws-star, stardust can run over any transport thus removing the requirement for websockets (but don't even think about running a stardust server over webrtc-star ;) )\n\nconst Stardust = or(and(Reliable, base('p2p-stardust'), base('ipfs')), and(Reliable, base('p2p-stardust')));\n\nlet _IPFS = or(and(Reliable, base('ipfs')), WebRTCStar, base('ipfs'));\n\nconst _Circuit = or(and(_IPFS, base('p2p-circuit'), _IPFS), and(_IPFS, base('p2p-circuit')), and(base('p2p-circuit'), _IPFS), and(Reliable, base('p2p-circuit')), and(base('p2p-circuit'), Reliable), base('p2p-circuit'));\n\nconst CircuitRecursive = () => or(and(_Circuit, CircuitRecursive), _Circuit);\n\nconst Circuit = CircuitRecursive();\nconst IPFS = or(and(Circuit, _IPFS, Circuit), and(_IPFS, Circuit), and(Circuit, _IPFS), Circuit, _IPFS);\nexports.DNS = DNS;\nexports.DNS4 = DNS4;\nexports.DNS6 = DNS6;\nexports.IP = IP;\nexports.TCP = TCP;\nexports.UDP = UDP;\nexports.UTP = UTP;\nexports.HTTP = HTTP;\nexports.HTTPS = HTTPS;\nexports.WebSockets = WebSockets;\nexports.WebSocketsSecure = WebSocketsSecure;\nexports.WebSocketStar = WebSocketStar;\nexports.WebRTCStar = WebRTCStar;\nexports.WebRTCDirect = WebRTCDirect;\nexports.Reliable = Reliable;\nexports.Stardust = Stardust;\nexports.Circuit = Circuit;\nexports.IPFS = IPFS;\n/*\n * Validation funcs\n */\n\nfunction makeMatchesFunction(partialMatch) {\n  return function matches(a) {\n    if (!multiaddr.isMultiaddr(a)) {\n      try {\n        a = multiaddr(a);\n      } catch (err) {\n        // catch error\n        return false; // also if it's invalid it's propably not matching as well so return false\n      }\n    }\n\n    let out = partialMatch(a.protoNames());\n\n    if (out === null) {\n      return false;\n    }\n\n    return out.length === 0;\n  };\n}\n\nfunction and() {\n  const args = Array.from(arguments);\n\n  function partialMatch(a) {\n    if (a.length < args.length) {\n      return null;\n    }\n\n    args.some(arg => {\n      a = typeof arg === 'function' ? arg().partialMatch(a) : arg.partialMatch(a);\n\n      if (a === null) {\n        return true;\n      }\n    });\n    return a;\n  }\n\n  return {\n    toString: function () {\n      return '{ ' + args.join(' ') + ' }';\n    },\n    input: args,\n    matches: makeMatchesFunction(partialMatch),\n    partialMatch: partialMatch\n  };\n}\n\nfunction or() {\n  const args = Array.from(arguments);\n\n  function partialMatch(a) {\n    let out = null;\n    args.some(arg => {\n      const res = typeof arg === 'function' ? arg().partialMatch(a) : arg.partialMatch(a);\n\n      if (res) {\n        out = res;\n        return true;\n      }\n    });\n    return out;\n  }\n\n  const result = {\n    toString: function () {\n      return '{ ' + args.join(' ') + ' }';\n    },\n    input: args,\n    matches: makeMatchesFunction(partialMatch),\n    partialMatch: partialMatch\n  };\n  return result;\n}\n\nfunction base(n) {\n  const name = n;\n\n  function matches(a) {\n    if (typeof a === 'string') {\n      try {\n        a = multiaddr(a);\n      } catch (err) {\n        // catch error\n        return false; // also if it's invalid it's propably not matching as well so return false\n      }\n    }\n\n    const pnames = a.protoNames();\n\n    if (pnames.length === 1 && pnames[0] === name) {\n      return true;\n    }\n\n    return false;\n  }\n\n  function partialMatch(protos) {\n    if (protos.length === 0) {\n      return null;\n    }\n\n    if (protos[0] === name) {\n      return protos.slice(1);\n    }\n\n    return null;\n  }\n\n  return {\n    toString: function () {\n      return name;\n    },\n    matches: matches,\n    partialMatch: partialMatch\n  };\n}","map":null,"metadata":{},"sourceType":"script"}