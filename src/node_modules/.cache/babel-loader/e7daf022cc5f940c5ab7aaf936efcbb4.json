{"ast":null,"code":"'use strict';\n\nconst _require = require('readable-stream'),\n      Duplex = _require.Duplex;\n\nclass PullDuplexStream extends Duplex {\n  constructor(source, sink, options) {\n    super(options);\n    this.source = source;\n    this.drainingSource = false;\n    this.sink = sink;\n    this.input = [];\n    this.writeCallbacks = [];\n    this.internalSourceCallbacks = [];\n\n    if (this.sink) {\n      this.sink(this._internalSource.bind(this));\n    }\n  }\n\n  drainPull() {\n    const self = this;\n    this.drainingSource = true;\n    this.source(null, function next(end, data) {\n      if (end instanceof Error) {\n        return self.emit('error', end);\n      }\n\n      if (end) {\n        return self.push(null);\n      }\n\n      if (self.push(data)) {\n        self.source(null, next);\n      } else {\n        self.drainingSource = false;\n      }\n    });\n  }\n\n  _read() {\n    if (this.source && !this.drainingSource) {\n      this.drainPull();\n    }\n  }\n\n  _write(chunk, encoding, callback) {\n    if (this.internalSourceCallbacks.length > 0) {\n      this.internalSourceCallbacks.shift()(null, chunk);\n      callback();\n    } else {\n      this.input.push(chunk);\n      this.writeCallbacks.push(callback);\n    }\n  }\n\n  _internalSource(end, cb) {\n    if (end) {\n      if (this.writeCallbacks.length > 0) {\n        // call write callback with error\n        this.writeCallbacks.shift()(end instanceof Error ? end : new Error('Aborted'));\n      }\n\n      return cb(end);\n    }\n\n    if (this.input.length > 0) {\n      cb(null, this.input.shift());\n      this.writeCallbacks.shift()();\n    } else {\n      this.internalSourceCallbacks.push(cb);\n    }\n  }\n\n  _final(callback) {\n    // end the internal source\n    if (this.internalSourceCallbacks.length > 0) {\n      this.internalSourceCallbacks.shift()(true);\n    }\n\n    callback();\n  }\n\n  _destroy(err, cb) {\n    // abort the source\n    if (!this._readableState.ended && this.source) {\n      this.source(true, () => {// do nothing\n      });\n    } // propagate error to sink\n\n\n    if (this.internalSourceCallbacks.length > 0) {\n      this.internalSourceCallbacks.shift()(err);\n    }\n\n    cb(err);\n  }\n\n}\n\nfunction wrapper(source, sink, options) {\n  if (source && typeof source === 'object') {\n    source = source.source;\n    sink = source.sink;\n  }\n\n  return new PullDuplexStream(source, sink, Object.assign({\n    readableObjectMode: true,\n    writableObjectMode: true\n  }, options));\n}\n\nmodule.exports = {\n  duplex: wrapper,\n  readable: (source, options) => wrapper(source, null, options),\n  writeable: (sink, options) => wrapper(null, sink, options)\n};","map":null,"metadata":{},"sourceType":"script"}