{"ast":null,"code":"'use strict';\n/* global self */\n\nconst isIPFS = require('is-ipfs');\n\nconst _require = require('buffer'),\n      Buffer = _require.Buffer;\n\nconst CID = require('cids');\n\nconst multiaddr = require('multiaddr');\n\nconst multibase = require('multibase');\n\nconst multicodec = require('multicodec');\n\nconst multihash = require('multihashes');\n\nconst PeerId = require('peer-id');\n\nconst PeerInfo = require('peer-info');\n\nconst loadCommands = require('./utils/load-commands');\n\nconst getConfig = require('./utils/default-config');\n\nconst sendRequest = require('./utils/send-request');\n\nfunction ipfsClient(hostOrMultiaddr, port, userOptions) {\n  // convert all three params to objects that we can merge.\n  let options = {};\n\n  if (!hostOrMultiaddr) {\n    // autoconfigure host and port in browser\n    if (typeof self !== 'undefined') {\n      options = urlToOptions(self.location);\n    }\n  } else if (multiaddr.isMultiaddr(hostOrMultiaddr)) {\n    options = maToOptions(hostOrMultiaddr);\n  } else if (typeof hostOrMultiaddr === 'object') {\n    options = hostOrMultiaddr;\n  } else if (typeof hostOrMultiaddr === 'string') {\n    if (hostOrMultiaddr[0] === '/') {\n      // throws if multiaddr is malformed or can't be converted to a nodeAddress\n      options = maToOptions(multiaddr(hostOrMultiaddr));\n    } else {\n      // hostOrMultiaddr is domain or ip address as a string\n      options.host = hostOrMultiaddr;\n    }\n  }\n\n  if (port && typeof port !== 'object') {\n    port = {\n      port: port\n    };\n  }\n\n  const config = Object.assign(getConfig(), options, port, userOptions);\n  const requestAPI = sendRequest(config);\n  const cmds = loadCommands(requestAPI, config);\n  cmds.send = requestAPI;\n  return cmds;\n}\n\nfunction maToOptions(multiaddr) {\n  // ma.nodeAddress() throws if multiaddr can't be converted to a nodeAddress\n  const nodeAddr = multiaddr.nodeAddress();\n  const protos = multiaddr.protos(); // only http and https are allowed as protocol,\n  // anything else will be replaced with http\n\n  const exitProtocol = protos[protos.length - 1].name;\n  return {\n    host: nodeAddr.address,\n    port: nodeAddr.port,\n    protocol: exitProtocol.startsWith('http') ? exitProtocol : 'http'\n  };\n}\n\nfunction urlToOptions(url) {\n  return {\n    host: url.hostname,\n    port: url.port || (url.protocol.startsWith('https') ? 443 : 80),\n    protocol: url.protocol.startsWith('http') ? url.protocol.split(':')[0] : 'http'\n  };\n}\n\nmodule.exports = ipfsClient;\nObject.assign(module.exports, {\n  isIPFS,\n  Buffer,\n  CID,\n  multiaddr,\n  multibase,\n  multicodec,\n  multihash,\n  PeerId,\n  PeerInfo\n});","map":null,"metadata":{},"sourceType":"script"}